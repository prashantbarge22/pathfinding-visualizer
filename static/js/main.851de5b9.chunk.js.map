{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/algorithmUtils.js","algorithms/dijkstra.js","algorithms/a-star.js","PathfindingVisualizer/PathfindingVisualizer.jsx","algorithms/dfs.js","algorithms/bfs.js","algorithms/greedy-bfs.js","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","nodeDescriptor","id","className","Component","sortedNodes","unvisitedNodes","sort","a","b","distance","getNeighbors","node","grid","neighbors","push","length","filter","neighbor","isVisited","manhattanDistance","finishNode","Math","abs","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","previousNode","dijkstra","startNode","visitedNodesInOrder","nodes","utils","minNode","shift","Infinity","aStarGetNeighbors","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisualizer","state","mouseIsPressed","specialNodePressed","currentAlgorithm","createInitialGrid","setState","document","getElementById","disabled","newGrid","createNewGridWithStartNodeToggled","createNewGridWithFinishNodeToggled","createNewGridWithWallToggled","button","disable","navbar","buttons","getElementsByTagName","i","setTimeout","toggleInputs","animateShortestPath","animateAlgorithm","nodeStack","pop","dfs","nodeQueue","bfs","heuristic","nodePQ","node1","node2","greedyBfs","openList","lowestIndex","f","splice","gScore","g","gScoreIsBest","h","aStar","clearGrid","visualizeDijkstra","visualizeDFS","visualizeBFS","visualizeGreedyBFS","visualizeAStar","showAlgoDescription","algorithmSelect","options","selectedIndex","value","keepWall","resetNode","individualDescs","currAlgoID","style","display","window","open","onChange","changeCurrentAlgo","onClick","visualizeAlgorithm","githubLink","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.851de5b9.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      row,\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n    } = this.props;\n\n    const nodeDescriptor = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : \"\";\n\n    return (\n      <div\n        id={`node (${row},${col})`}\n        className={`node ${nodeDescriptor}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","export function getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nexport function sortedNodes(unvisitedNodes) {\n  return unvisitedNodes.sort((a, b) => a.distance - b.distance);\n}\n\nexport function getNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n  if (row > 0) {\n    neighbors.push(grid[row - 1][col]);\n  }\n  if (col < grid[0].length - 1) {\n    neighbors.push(grid[row][col + 1]);\n  }\n  if (row < grid.length - 1) {\n    neighbors.push(grid[row + 1][col]);\n  }\n  if (col > 0) {\n    neighbors.push(grid[row][col - 1]);\n  }\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nexport function manhattanDistance(node, finishNode) {\n  return (\n    Math.abs(node.row - finishNode.row) + Math.abs(node.col - finishNode.col)\n  );\n}\n\nexport default function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import * as utils from \"./algorithmUtils.js\";\n\nexport default function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = utils.getAllNodes(grid);\n  startNode.distance = 0;\n  while (!!unvisitedNodes.length) {\n    const minNode = utils.sortedNodes(unvisitedNodes).shift();\n    if (minNode.isWall) continue;\n    if (minNode.distance === Infinity) return visitedNodesInOrder;\n    minNode.isVisited = true;\n    visitedNodesInOrder.push(minNode);\n    if (minNode === finishNode) return visitedNodesInOrder;\n    const neighbors = utils.getNeighbors(minNode, grid);\n    for (let neighbor of neighbors) {\n      neighbor.distance = minNode.distance + 1;\n      neighbor.previousNode = minNode;\n    }\n  }\n}\n","export default function aStar(grid, startNode, finishNode, heuristic) {\n  const visitedNodesInOrder = [];\n  const openList = [];\n  openList.push(startNode);\n  while (!!openList.length) {\n    let lowestIndex = 0;\n    for (let i = 0; i < openList.length; i++) {\n      if (openList[i].f < openList[lowestIndex].f) {\n        lowestIndex = i;\n      }\n    }\n    const currentNode = openList[lowestIndex];\n\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n    if (currentNode === finishNode) return visitedNodesInOrder;\n    openList.splice(lowestIndex, 1);\n    const neighbors = aStarGetNeighbors(currentNode, grid);\n    for (let neighbor of neighbors) {\n      const gScore = currentNode.g + 1;\n      let gScoreIsBest = false;\n      if (neighbor in visitedNodesInOrder || neighbor.isWall) continue;\n      if (!neighbor.isVisited) {\n        gScoreIsBest = true;\n        neighbor.h = heuristic(neighbor, finishNode);\n        neighbor.isVisited = true;\n        openList.push(neighbor);\n      } else if (gScore < neighbor.g) {\n        gScoreIsBest = true;\n      }\n      if (gScoreIsBest) {\n        neighbor.previousNode = currentNode;\n        neighbor.g = gScore;\n        neighbor.f = neighbor.g + neighbor.h;\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\n\nexport function aStarGetNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n  if (row > 0) {\n    neighbors.push(grid[row - 1][col]);\n  }\n  if (col < grid[0].length - 1) {\n    neighbors.push(grid[row][col + 1]);\n  }\n  if (row < grid.length - 1) {\n    neighbors.push(grid[row + 1][col]);\n  }\n  if (col > 0) {\n    neighbors.push(grid[row][col - 1]);\n  }\n  return neighbors;\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport \"./PathfindingVisualizer.css\";\nimport dijkstra from \"../algorithms/dijkstra\";\nimport dfs from \"../algorithms/dfs\";\nimport bfs from \"../algorithms/bfs\";\nimport greedyBfs from \"../algorithms/greedy-bfs\";\nimport getNodesInShortestPathOrder, {\n  manhattanDistance,\n} from \"../algorithms/algorithmUtils\";\nimport aStar from \"../algorithms/a-star\";\n\nlet START_NODE_ROW = 10;\nlet START_NODE_COL = 10;\nlet FINISH_NODE_ROW = 10;\nlet FINISH_NODE_COL = 40;\n\nconst GRID_HEIGHT = 20;\nconst GRID_WIDTH = 50;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      specialNodePressed: \"none\",\n      currentAlgorithm: \"dijkstra\", // default\n    };\n  }\n\n  componentDidMount() {\n    const grid = createInitialGrid();\n    this.setState({ grid });\n  }\n\n  handleMouseDown(row, col) {\n    // if buttons are disabled, don't produce walls either\n    const button = document.getElementById(\"viz-btn\");\n    if (button.disabled === true) {\n      return;\n    }\n    const node = this.state.grid[row][col];\n    if (node.isStart) {\n      const newGrid = createNewGridWithStartNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({\n        grid: newGrid,\n        mouseIsPressed: true,\n        specialNodePressed: \"start\",\n      });\n    } else if (node.isFinish) {\n      const newGrid = createNewGridWithFinishNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({\n        grid: newGrid,\n        mouseIsPressed: true,\n        specialNodePressed: \"finish\",\n      });\n    } else {\n      const newGrid = createNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  }\n\n  handleMouseEnter(row, col) {\n    const button = document.getElementById(\"viz-btn\");\n    if (!this.state.mouseIsPressed || button.disabled === true) return;\n    if (this.state.specialNodePressed === \"start\") {\n      const newGrid = createNewGridWithStartNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid });\n    } else if (this.state.specialNodePressed === \"finish\") {\n      const newGrid = createNewGridWithFinishNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid });\n    } else {\n      const newGrid = createNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid });\n    }\n  }\n\n  handleMouseUp(row, col) {\n    if (this.state.specialNodePressed === \"start\") {\n      const newGrid = createNewGridWithStartNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid });\n    } else if (this.state.specialNodePressed === \"finish\") {\n      const newGrid = createNewGridWithFinishNodeToggled(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid });\n    }\n    this.setState({ mouseIsPressed: false, specialNodePressed: \"none\" });\n  }\n\n  updateStartNode() {}\n\n  toggleInputs(disable = false) {\n    const navbar = document.getElementById(\"navbar\");\n    const buttons = navbar.getElementsByTagName(\"button\");\n    if (disable === true) {\n      for (let button of buttons) {\n        button.disabled = true;\n      }\n    } else {\n      for (let button of buttons) {\n        button.disabled = false;\n      }\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        // console.log(node);\n        if (nodesInShortestPathOrder.length > 1) {\n          if (i === 0) {\n            document.getElementById(\n              `node (${node.row},${node.col})`\n            ).className = \"node start-node-shortest-path\";\n          } else if (i === nodesInShortestPathOrder.length - 1) {\n            document.getElementById(\n              `node (${node.row},${node.col})`\n            ).className = \"node finish-node-shortest-path\";\n            this.toggleInputs(false);\n          } else {\n            document.getElementById(\n              `node (${node.row},${node.col})`\n            ).className = \"node node-shortest-path\";\n          }\n        } else {\n          this.toggleInputs(false);\n        }\n      }, 30 * i);\n    }\n  }\n\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\n    // disable button input while the algorithm is running\n    this.toggleInputs(true);\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (i === 0) {\n          document.getElementById(`node (${node.row},${node.col})`).className =\n            \"node start-node-visited\";\n        } else if (\n          i === visitedNodesInOrder.length - 1 &&\n          nodesInShortestPathOrder.length > 1\n        ) {\n          document.getElementById(`node (${node.row},${node.col})`).className =\n            \"node finish-node-visited\";\n        } else {\n          document.getElementById(`node (${node.row},${node.col})`).className =\n            \"node node-visited\";\n        }\n      }, 10 * i);\n    }\n  }\n\n  visualizeDijkstra(grid, startNode, finishNode) {\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  visualizeDFS(grid, startNode, finishNode) {\n    const visitedNodesInOrder = dfs(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  visualizeBFS(grid, startNode, finishNode) {\n    const visitedNodesInOrder = bfs(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  visualizeGreedyBFS(grid, startNode, finishNode) {\n    const visitedNodesInOrder = greedyBfs(\n      grid,\n      startNode,\n      finishNode,\n      manhattanDistance\n    );\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  visualizeAStar(grid, startNode, finishNode) {\n    const visitedNodesInOrder = aStar(\n      grid,\n      startNode,\n      finishNode,\n      manhattanDistance\n    );\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  visualizeAlgorithm() {\n    this.clearGrid(true);\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    switch (this.state.currentAlgorithm) {\n      case \"dijkstra\":\n        this.visualizeDijkstra(grid, startNode, finishNode);\n        break;\n      case \"dfs\":\n        this.visualizeDFS(grid, startNode, finishNode);\n        break;\n      case \"bfs\":\n        this.visualizeBFS(grid, startNode, finishNode);\n        break;\n      case \"greedy-bfs\":\n        this.visualizeGreedyBFS(grid, startNode, finishNode);\n        break;\n      case \"a-star\":\n        this.visualizeAStar(grid, startNode, finishNode);\n        break;\n      default:\n    }\n    this.showAlgoDescription();\n  }\n\n  changeCurrentAlgo() {\n    const algorithmSelect = document.getElementById(\"algorithm-select\");\n    const selectedAlgorithm =\n      algorithmSelect.options[algorithmSelect.selectedIndex].value;\n    switch (selectedAlgorithm) {\n      case \"dijkstra\":\n        this.setState({ currentAlgorithm: \"dijkstra\" });\n        break;\n      case \"dfs\":\n        this.setState({ currentAlgorithm: \"dfs\" });\n        break;\n      case \"bfs\":\n        this.setState({ currentAlgorithm: \"bfs\" });\n        break;\n      case \"greedy-bfs\":\n        this.setState({ currentAlgorithm: \"greedy-bfs\" });\n        break;\n      case \"a-star\":\n        this.setState({ currentAlgorithm: \"a-star\" });\n        break;\n      default:\n    }\n  }\n\n  resetNode(node, keepWall = false) {\n    node.distance = Infinity;\n    node.isVisited = false;\n    node.previousNode = null;\n    if (!keepWall) {\n      node.isWall = false;\n    }\n  }\n\n  clearGrid(keepWall = false) {\n    const { grid } = this.state;\n    for (let row of grid) {\n      for (let node of row) {\n        if (node.row === START_NODE_ROW && node.col === START_NODE_COL) {\n          document.getElementById(`node (${node.row},${node.col})`).className =\n            \"node node-start\";\n        } else if (\n          node.row === FINISH_NODE_ROW &&\n          node.col === FINISH_NODE_COL\n        ) {\n          document.getElementById(`node (${node.row},${node.col})`).className =\n            \"node node-finish\";\n        } else if (node.isWall && keepWall) {\n          continue;\n        } else {\n          document.getElementById(`node (${node.row},${node.col})`).className =\n            \"node \";\n        }\n        this.resetNode(node, keepWall);\n      }\n    }\n  }\n\n  showAlgoDescription() {\n    const { currentAlgorithm } = this.state;\n    const allDescs = document.getElementById(\"algo-desc\");\n    const individualDescs = allDescs.getElementsByTagName(\"*\");\n    const currAlgoID = `${currentAlgorithm}-desc`;\n    for (let i of individualDescs) {\n      if (i.id === currAlgoID) {\n        i.style.display = \"block\";\n      } else {\n        i.style.display = \"none\";\n      }\n    }\n  }\n\n  githubLink() {\n    window.open(\"https://github.com/vincent-ngo31/pathfinding-visualizer\");\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n    return (\n      <div id=\"page\">\n        <div id=\"navbar\">\n          <header className=\"header\">\n            <h1>Pathfinding Visualizer</h1>\n          </header>\n          <div id=\"algo-select-package\">\n            <label id=\"algo-select-label\">Choose an algorithm:</label>\n            <select\n              id=\"algorithm-select\"\n              onChange={() => this.changeCurrentAlgo()}\n            >\n              <option value=\"dijkstra\">Dijkstra's Algorithm</option>\n              <option value=\"dfs\">Depth-first Search</option>\n              <option value=\"bfs\">Breadth-first Search</option>\n              <option value=\"greedy-bfs\">Greedy Best-first Search</option>\n              <option value=\"a-star\">A* Search</option>\n            </select>\n          </div>\n          <button id=\"viz-btn\" onClick={() => this.visualizeAlgorithm()}>\n            Visualize!\n          </button>\n          <button id=\"clear-btn\" onClick={() => this.clearGrid()}>\n            Clear Grid\n          </button>\n          <button id=\"src-btn\" onClick={() => this.githubLink()}>\n            Source Code\n          </button>\n        </div>\n        <p id=\"instructions\">\n          Instructions: Choose an algorithm. You can draw \"walls\" or change the\n          positions of the start and end nodes by clicking and dragging your\n          mouse across the grid. Click the \"Visualize!\" button to see the\n          algorithm explore the grid and find a path from the start node to the\n          end node.\n        </p>\n        <header id=\"algo-desc\">\n          <h3 id=\"dijkstra-desc\">\n            Dijkstra's algorithm is a weighted search algorithm that guarantees\n            the shortest path!\n          </h3>\n          <h3 id=\"dfs-desc\">\n            Depth-first search is an weighted search algorithm that does not\n            guarantee the shortest path!\n          </h3>\n          <h3 id=\"bfs-desc\">\n            Breadth-first search is an unweighted search algorithm that\n            guarantees the shortest path!\n          </h3>\n          <h3 id=\"greedy-bfs-desc\">\n            Greedy best-first search is a weighted search algorithm that does\n            not guarantee the shortest path!\n          </h3>\n          <h3 id=\"a-star-desc\">\n            A* search is a weighted search algorithm that guarantees the\n            shortest path!\n          </h3>\n        </header>\n        <div id=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx} className=\"row\">\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      row={row}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp(row, col)}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\nconst createInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < GRID_HEIGHT; row++) {\n    const currentRow = [];\n    for (let col = 0; col < GRID_WIDTH; col++) {\n      currentRow.push(createNode(row, col));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    g: 0,\n    h: 0,\n    f: 0,\n  };\n};\n\nconst createNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: true,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst createNewGridWithStartNodeToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n\n  const oldStartNode = newGrid[START_NODE_ROW][START_NODE_COL];\n  oldStartNode.isStart = false;\n\n  START_NODE_ROW = row;\n  START_NODE_COL = col;\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isStart: true,\n  };\n  newGrid[row][col] = newNode;\n\n  return newGrid;\n};\n\nconst createNewGridWithFinishNodeToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n\n  const oldFinishNode = newGrid[FINISH_NODE_ROW][FINISH_NODE_COL];\n  oldFinishNode.isFinish = false;\n\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isFinish: true,\n  };\n  newGrid[row][col] = newNode;\n  FINISH_NODE_ROW = row;\n  FINISH_NODE_COL = col;\n  return newGrid;\n};\n","import * as utils from \"./algorithmUtils.js\";\n\nexport default function dfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  const nodeStack = [];\n  nodeStack.push(startNode);\n  while (!!nodeStack.length) {\n    const currentNode = nodeStack.pop();\n    if (currentNode.isWall) continue;\n    visitedNodesInOrder.push(currentNode);\n    if (currentNode === finishNode) return visitedNodesInOrder;\n    if (currentNode.isVisited === false) {\n      currentNode.isVisited = true;\n      const neighbors = utils.getNeighbors(currentNode, grid);\n      for (let neighbor of neighbors) {\n        nodeStack.push(neighbor);\n        neighbor.previousNode = currentNode;\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\n","import * as utils from \"./algorithmUtils.js\";\n\nexport default function bfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  const nodeQueue = [];\n  nodeQueue.push(startNode);\n  while (!!nodeQueue.length) {\n    const currentNode = nodeQueue.shift();\n    if (currentNode.isWall) continue;\n    visitedNodesInOrder.push(currentNode);\n    if (currentNode === finishNode) return visitedNodesInOrder;\n    if (currentNode.isVisited === false) {\n      currentNode.isVisited = true;\n      const neighbors = utils.getNeighbors(currentNode, grid);\n      for (let neighbor of neighbors) {\n        nodeQueue.push(neighbor);\n        neighbor.previousNode = currentNode;\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\n","import * as utils from \"./algorithmUtils.js\";\n\nexport default function greedyBfs(grid, startNode, finishNode, heuristic) {\n  const visitedNodesInOrder = [];\n  const nodePQ = [];\n  nodePQ.push(startNode);\n  while (!!nodePQ.length) {\n    const currentNode = nodePQ.shift();\n    if (currentNode.isWall) continue;\n    visitedNodesInOrder.push(currentNode);\n    if (currentNode === finishNode) return visitedNodesInOrder;\n    if (currentNode.isVisited === false) {\n      currentNode.isVisited = true;\n      const neighbors = utils.getNeighbors(currentNode, grid);\n      for (let neighbor of neighbors) {\n        nodePQ.push(neighbor);\n        neighbor.previousNode = currentNode;\n        nodePQ.sort(\n          (node1, node2) =>\n            heuristic(node1, finishNode) - heuristic(node2, finishNode)\n        );\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\n","import React from \"react\";\nimport \"./App.css\";\n\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}